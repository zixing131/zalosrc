package org.webrtc;

import android.opengl.GLES20;
import ho0.AbstractC20110a;
import java.nio.FloatBuffer;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.Map;
import org.webrtc.RendererCommon;
import org.webrtc.videofilter.ZVideoFilter;
import org.webrtc.videofilter.ZVideoFilterManager;

/* loaded from: classes7.dex */
public class GlRectDrawer implements RendererCommon.GlDrawer {
    private static final String BLACK_CIRCLE_FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\n\nvoid main() {\n  float r2 = (real_coord.x - 0.5) * (real_coord.x - 0.5) + (real_coord.y - 0.5)*(real_coord.y - 0.5);\n  if (r2 > 0.25) \n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else \n      gl_FragColor = vec4(0.0,0.0,0.0,1.0);\n}\n";
    private static final String BLACK_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform samplerExternalOES oes_tex;\nuniform float viewWidth;\nuniform float viewHeight;\nuniform float cornerRadius;\nbool isOutsideBottomLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideBottomRigthCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopRightCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideCorners() {\n       return isOutsideBottomLelftCorner() ||               isOutsideBottomRigthCorner() ||               isOutsideTopLelftCorner() ||               isOutsideTopRightCorner();\n}\nvoid main() {\n  if (isOutsideCorners()) \n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else \n      gl_FragColor = vec4(0.0,0.0,0.0,1.0);\n}\n";
    private static final String BLACK_FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nvarying vec2 interp_tc;\n\nvoid main() {\n  gl_FragColor = vec4(0.0,0.0,0.0,1.0);\n}\n";
    private static final String BLUR_COORDINATE = "        blurCoordinates[0] = interp_tc.xy + singleStepOffset * vec2(0.0, -10.0);\n        blurCoordinates[1] = interp_tc.xy + singleStepOffset * vec2(0.0, 10.0);\n        blurCoordinates[2] = interp_tc.xy + singleStepOffset * vec2(-10.0, 0.0);\n        blurCoordinates[3] = interp_tc.xy + singleStepOffset * vec2(10.0, 0.0);\n        blurCoordinates[4] = interp_tc.xy + singleStepOffset * vec2(5.0, -8.0);\n        blurCoordinates[5] = interp_tc.xy + singleStepOffset * vec2(5.0, 8.0);\n        blurCoordinates[6] = interp_tc.xy + singleStepOffset * vec2(-5.0, 8.0);\n        blurCoordinates[7] = interp_tc.xy + singleStepOffset * vec2(-5.0, -8.0);\n        blurCoordinates[8] = interp_tc.xy + singleStepOffset * vec2(8.0, -5.0);\n        blurCoordinates[9] = interp_tc.xy + singleStepOffset * vec2(8.0, 5.0);\n        blurCoordinates[10] = interp_tc.xy + singleStepOffset * vec2(-8.0, 5.0);\n        blurCoordinates[11] = interp_tc.xy + singleStepOffset * vec2(-8.0, -5.0);\n        blurCoordinates[12] = interp_tc.xy + singleStepOffset * vec2(0.0, -6.0);\n        blurCoordinates[13] = interp_tc.xy + singleStepOffset * vec2(0.0, 6.0);\n        blurCoordinates[14] = interp_tc.xy + singleStepOffset * vec2(6.0, 0.0);\n        blurCoordinates[15] = interp_tc.xy + singleStepOffset * vec2(-6.0, 0.0);\n        blurCoordinates[16] = interp_tc.xy + singleStepOffset * vec2(-4.0, -4.0);\n        blurCoordinates[17] = interp_tc.xy + singleStepOffset * vec2(-4.0, 4.0);\n        blurCoordinates[18] = interp_tc.xy + singleStepOffset * vec2(4.0, -4.0);\n        blurCoordinates[19] = interp_tc.xy + singleStepOffset * vec2(4.0, 4.0);\n";
    private static final String BLUR_OES_CIRCLE_FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform samplerExternalOES oes_tex;\nuniform float exposureValue;\nvec2 singleStepOffset = vec2(0.0015625, 0.0027778);\nmediump float params = 1.0;\nconst highp vec3 W = vec3(0.299,0.587,0.114);\nvec2 blurCoordinates[20];\nfloat hardLight(float color)\n{\n\tif(color <= 0.5)\n\t\tcolor = color * color * 2.0;\n\telse\n\t\tcolor = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n\treturn color;\n}\nvoid main(){\n  float r2 = (real_coord.x - 0.5) * (real_coord.x - 0.5) + (real_coord.y - 0.5)*(real_coord.y - 0.5);\n  if (r2 > 0.25) \n     gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else {\n    vec3 centralColor = texture2D(oes_tex, interp_tc).rgb;\n    vec3 processedColor = centralColor;\n    float r = centralColor.r;\n    float g = centralColor.g;\n    float b = centralColor.b;\n     float Y  = 0.0 + 0.299 * r + 0.587 * g + 0.114 * b;\n     float Cb = 0.5 - 0.169 * r - 0.331 * g + 0.5   * b;\n     float Cr = 0.5 + 0.5   * r - 0.419 * g - 0.081 * b;\n     if ((Cb > 0.3008 && Cb < 0.5273 && Cr > 0.5078 && Cr < 0.6836) || Y > 0.7 ) \n    {\n        blurCoordinates[0] = interp_tc.xy + singleStepOffset * vec2(0.0, -10.0);\n        blurCoordinates[1] = interp_tc.xy + singleStepOffset * vec2(0.0, 10.0);\n        blurCoordinates[2] = interp_tc.xy + singleStepOffset * vec2(-10.0, 0.0);\n        blurCoordinates[3] = interp_tc.xy + singleStepOffset * vec2(10.0, 0.0);\n        blurCoordinates[4] = interp_tc.xy + singleStepOffset * vec2(5.0, -8.0);\n        blurCoordinates[5] = interp_tc.xy + singleStepOffset * vec2(5.0, 8.0);\n        blurCoordinates[6] = interp_tc.xy + singleStepOffset * vec2(-5.0, 8.0);\n        blurCoordinates[7] = interp_tc.xy + singleStepOffset * vec2(-5.0, -8.0);\n        blurCoordinates[8] = interp_tc.xy + singleStepOffset * vec2(8.0, -5.0);\n        blurCoordinates[9] = interp_tc.xy + singleStepOffset * vec2(8.0, 5.0);\n        blurCoordinates[10] = interp_tc.xy + singleStepOffset * vec2(-8.0, 5.0);\n        blurCoordinates[11] = interp_tc.xy + singleStepOffset * vec2(-8.0, -5.0);\n        blurCoordinates[12] = interp_tc.xy + singleStepOffset * vec2(0.0, -6.0);\n        blurCoordinates[13] = interp_tc.xy + singleStepOffset * vec2(0.0, 6.0);\n        blurCoordinates[14] = interp_tc.xy + singleStepOffset * vec2(6.0, 0.0);\n        blurCoordinates[15] = interp_tc.xy + singleStepOffset * vec2(-6.0, 0.0);\n        blurCoordinates[16] = interp_tc.xy + singleStepOffset * vec2(-4.0, -4.0);\n        blurCoordinates[17] = interp_tc.xy + singleStepOffset * vec2(-4.0, 4.0);\n        blurCoordinates[18] = interp_tc.xy + singleStepOffset * vec2(4.0, -4.0);\n        blurCoordinates[19] = interp_tc.xy + singleStepOffset * vec2(4.0, 4.0);\n        float sampleColor = centralColor.g * 20.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[0]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[1]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[2]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[3]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[4]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[5]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[6]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[7]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[8]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[9]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[10]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[11]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[12]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[13]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[14]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[15]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[16]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[17]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[18]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[19]).g * 2.0;\n        sampleColor = sampleColor / 48.0;\n        float highPass = centralColor.g - sampleColor + 0.5;\n        for(int i = 0; i < 5; i++)\n        {\n            highPass = hardLight(highPass);\n        }\n        float luminance = dot(centralColor, W);\n        float alpha = pow(luminance, params);\n        vec3 smoothColor = centralColor + (centralColor-vec3(highPass))*alpha*0.1;\n        processedColor = vec3(mix(smoothColor.rgb, max(smoothColor, centralColor), alpha));\n    } else {\n        processedColor = centralColor;    }\n    float processedY  = 0.0 + 0.299 * processedColor.r + 0.587 * processedColor.g + 0.114 * processedColor.b;\n    if (processedY < 0.9) {\n       float value = exposureValue;\n       if (processedY * value > 0.9) {\n         value = 0.9 / processedY;\n       }\n       processedColor = processedColor * value;\n    }\n    gl_FragColor = vec4(processedColor.r, processedColor.g, processedColor.b, 1.);\n  }\n}\n";
    private static final String BLUR_OES_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform samplerExternalOES oes_tex;\nuniform float exposureValue;\nvec2 singleStepOffset = vec2(0.0015625, 0.0027778);\nmediump float params = 1.0;\nconst highp vec3 W = vec3(0.299,0.587,0.114);\nvec2 blurCoordinates[20];\nfloat hardLight(float color)\n{\n\tif(color <= 0.5)\n\t\tcolor = color * color * 2.0;\n\telse\n\t\tcolor = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n\treturn color;\n}\nuniform float viewWidth;\nuniform float viewHeight;\nuniform float cornerRadius;\nbool isOutsideBottomLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideBottomRigthCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopRightCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideCorners() {\n       return isOutsideBottomLelftCorner() ||               isOutsideBottomRigthCorner() ||               isOutsideTopLelftCorner() ||               isOutsideTopRightCorner();\n}\nvoid main() {\n  if (isOutsideCorners()) \n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else {\n    vec3 centralColor = texture2D(oes_tex, interp_tc).rgb;\n    vec3 processedColor = centralColor;\n    float r = centralColor.r;\n    float g = centralColor.g;\n    float b = centralColor.b;\n     float Y  = 0.0 + 0.299 * r + 0.587 * g + 0.114 * b;\n     float Cb = 0.5 - 0.169 * r - 0.331 * g + 0.5   * b;\n     float Cr = 0.5 + 0.5   * r - 0.419 * g - 0.081 * b;\n     if ((Cb > 0.3008 && Cb < 0.5273 && Cr > 0.5078 && Cr < 0.6836) || Y > 0.7 ) \n    {\n        blurCoordinates[0] = interp_tc.xy + singleStepOffset * vec2(0.0, -10.0);\n        blurCoordinates[1] = interp_tc.xy + singleStepOffset * vec2(0.0, 10.0);\n        blurCoordinates[2] = interp_tc.xy + singleStepOffset * vec2(-10.0, 0.0);\n        blurCoordinates[3] = interp_tc.xy + singleStepOffset * vec2(10.0, 0.0);\n        blurCoordinates[4] = interp_tc.xy + singleStepOffset * vec2(5.0, -8.0);\n        blurCoordinates[5] = interp_tc.xy + singleStepOffset * vec2(5.0, 8.0);\n        blurCoordinates[6] = interp_tc.xy + singleStepOffset * vec2(-5.0, 8.0);\n        blurCoordinates[7] = interp_tc.xy + singleStepOffset * vec2(-5.0, -8.0);\n        blurCoordinates[8] = interp_tc.xy + singleStepOffset * vec2(8.0, -5.0);\n        blurCoordinates[9] = interp_tc.xy + singleStepOffset * vec2(8.0, 5.0);\n        blurCoordinates[10] = interp_tc.xy + singleStepOffset * vec2(-8.0, 5.0);\n        blurCoordinates[11] = interp_tc.xy + singleStepOffset * vec2(-8.0, -5.0);\n        blurCoordinates[12] = interp_tc.xy + singleStepOffset * vec2(0.0, -6.0);\n        blurCoordinates[13] = interp_tc.xy + singleStepOffset * vec2(0.0, 6.0);\n        blurCoordinates[14] = interp_tc.xy + singleStepOffset * vec2(6.0, 0.0);\n        blurCoordinates[15] = interp_tc.xy + singleStepOffset * vec2(-6.0, 0.0);\n        blurCoordinates[16] = interp_tc.xy + singleStepOffset * vec2(-4.0, -4.0);\n        blurCoordinates[17] = interp_tc.xy + singleStepOffset * vec2(-4.0, 4.0);\n        blurCoordinates[18] = interp_tc.xy + singleStepOffset * vec2(4.0, -4.0);\n        blurCoordinates[19] = interp_tc.xy + singleStepOffset * vec2(4.0, 4.0);\n        float sampleColor = centralColor.g * 20.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[0]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[1]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[2]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[3]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[4]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[5]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[6]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[7]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[8]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[9]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[10]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[11]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[12]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[13]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[14]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[15]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[16]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[17]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[18]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[19]).g * 2.0;\n        sampleColor = sampleColor / 48.0;\n        float highPass = centralColor.g - sampleColor + 0.5;\n        for(int i = 0; i < 5; i++)\n        {\n            highPass = hardLight(highPass);\n        }\n        float luminance = dot(centralColor, W);\n        float alpha = pow(luminance, params);\n        vec3 smoothColor = centralColor + (centralColor-vec3(highPass))*alpha*0.1;\n        processedColor = vec3(mix(smoothColor.rgb, max(smoothColor, centralColor), alpha));\n    } else {\n        processedColor = centralColor;    }\n    float processedY  = 0.0 + 0.299 * processedColor.r + 0.587 * processedColor.g + 0.114 * processedColor.b;\n    if (processedY < 0.9) {\n       float value = exposureValue;\n       if (processedY * value > 0.9) {\n         value = 0.9 / processedY;\n       }\n       processedColor = processedColor * value;\n    }\n    gl_FragColor = vec4(processedColor.r, processedColor.g, processedColor.b, 1.);\n  }}\n";
    private static final String BLUR_OES_FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform samplerExternalOES oes_tex;\nuniform float exposureValue;\nvec2 singleStepOffset = vec2(0.0015625, 0.0027778);\nmediump float params = 1.0;\nconst highp vec3 W = vec3(0.299,0.587,0.114);\nvec2 blurCoordinates[20];\nfloat hardLight(float color)\n{\n\tif(color <= 0.5)\n\t\tcolor = color * color * 2.0;\n\telse\n\t\tcolor = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n\treturn color;\n}\nvoid main(){\n    vec3 centralColor = texture2D(oes_tex, interp_tc).rgb;\n    vec3 processedColor = centralColor;\n    float r = centralColor.r;\n    float g = centralColor.g;\n    float b = centralColor.b;\n     float Y  = 0.0 + 0.299 * r + 0.587 * g + 0.114 * b;\n     float Cb = 0.5 - 0.169 * r - 0.331 * g + 0.5   * b;\n     float Cr = 0.5 + 0.5   * r - 0.419 * g - 0.081 * b;\n     if ((Cb > 0.3008 && Cb < 0.5273 && Cr > 0.5078 && Cr < 0.6836) || Y > 0.7 ) \n    {\n        blurCoordinates[0] = interp_tc.xy + singleStepOffset * vec2(0.0, -10.0);\n        blurCoordinates[1] = interp_tc.xy + singleStepOffset * vec2(0.0, 10.0);\n        blurCoordinates[2] = interp_tc.xy + singleStepOffset * vec2(-10.0, 0.0);\n        blurCoordinates[3] = interp_tc.xy + singleStepOffset * vec2(10.0, 0.0);\n        blurCoordinates[4] = interp_tc.xy + singleStepOffset * vec2(5.0, -8.0);\n        blurCoordinates[5] = interp_tc.xy + singleStepOffset * vec2(5.0, 8.0);\n        blurCoordinates[6] = interp_tc.xy + singleStepOffset * vec2(-5.0, 8.0);\n        blurCoordinates[7] = interp_tc.xy + singleStepOffset * vec2(-5.0, -8.0);\n        blurCoordinates[8] = interp_tc.xy + singleStepOffset * vec2(8.0, -5.0);\n        blurCoordinates[9] = interp_tc.xy + singleStepOffset * vec2(8.0, 5.0);\n        blurCoordinates[10] = interp_tc.xy + singleStepOffset * vec2(-8.0, 5.0);\n        blurCoordinates[11] = interp_tc.xy + singleStepOffset * vec2(-8.0, -5.0);\n        blurCoordinates[12] = interp_tc.xy + singleStepOffset * vec2(0.0, -6.0);\n        blurCoordinates[13] = interp_tc.xy + singleStepOffset * vec2(0.0, 6.0);\n        blurCoordinates[14] = interp_tc.xy + singleStepOffset * vec2(6.0, 0.0);\n        blurCoordinates[15] = interp_tc.xy + singleStepOffset * vec2(-6.0, 0.0);\n        blurCoordinates[16] = interp_tc.xy + singleStepOffset * vec2(-4.0, -4.0);\n        blurCoordinates[17] = interp_tc.xy + singleStepOffset * vec2(-4.0, 4.0);\n        blurCoordinates[18] = interp_tc.xy + singleStepOffset * vec2(4.0, -4.0);\n        blurCoordinates[19] = interp_tc.xy + singleStepOffset * vec2(4.0, 4.0);\n        float sampleColor = centralColor.g * 20.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[0]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[1]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[2]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[3]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[4]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[5]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[6]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[7]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[8]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[9]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[10]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[11]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[12]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[13]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[14]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[15]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[16]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[17]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[18]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[19]).g * 2.0;\n        sampleColor = sampleColor / 48.0;\n        float highPass = centralColor.g - sampleColor + 0.5;\n        for(int i = 0; i < 5; i++)\n        {\n            highPass = hardLight(highPass);\n        }\n        float luminance = dot(centralColor, W);\n        float alpha = pow(luminance, params);\n        vec3 smoothColor = centralColor + (centralColor-vec3(highPass))*alpha*0.1;\n        processedColor = vec3(mix(smoothColor.rgb, max(smoothColor, centralColor), alpha));\n    } else {\n        processedColor = centralColor;    }\n    float processedY  = 0.0 + 0.299 * processedColor.r + 0.587 * processedColor.g + 0.114 * processedColor.b;\n    if (processedY < 0.9) {\n       float value = exposureValue;\n       if (processedY * value > 0.9) {\n         value = 0.9 / processedY;\n       }\n       processedColor = processedColor * value;\n    }\n    gl_FragColor = vec4(processedColor.r, processedColor.g, processedColor.b, 1.);\n}\n";
    private static final String BLUR_YUV_CIRCLE_FRAGMENT_SHADER_STRING = "precision mediump float;\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform sampler2D y_tex;\nuniform sampler2D u_tex;\nuniform sampler2D v_tex;\nuniform float exposureValue;\n\nvec2 singleStepOffset = vec2(0.0015625, 0.0027778);\nmediump float params = 1.0;\nconst highp vec3 W = vec3(0.299,0.587,0.114);\nvec2 blurCoordinates[20];\nfloat hardLight(float color)\n{\n\tif(color <= 0.5)\n\t\tcolor = color * color * 2.0;\n\telse\n\t\tcolor = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n\treturn color;\n}\nfloat greenValue(vec2 coord)\n{\n   return texture2D(y_tex, coord).r - 0.344 * (texture2D(u_tex, coord).r - 0.5) - 0.714 * (texture2D(v_tex, coord).r - 0.5);\n}\n\nvoid main() {\n  vec3 centralColor = vec3(0., 0., 0.);\n  vec3 processedColor = vec3(0., 0., 0.);\n  float r2 = (real_coord.x - 0.5) * (real_coord.x - 0.5) + (real_coord.y - 0.5)*(real_coord.y - 0.5);\n  if (r2 > 0.25) \n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else {\n     float y = texture2D(y_tex, interp_tc).r;\n     float u = texture2D(u_tex, interp_tc).r - 0.5;\n     float v = texture2D(v_tex, interp_tc).r - 0.5;\n     gl_FragColor = vec4(y + 1.403 * v,                           y - 0.344 * u - 0.714 * v,                           y + 1.77 * u, 1.);\n}\n}\n";
    private static final String BLUR_YUV_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING = "precision mediump float;\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform sampler2D y_tex;\nuniform sampler2D u_tex;\nuniform sampler2D v_tex;\nuniform float exposureValue;\n\nvec2 singleStepOffset = vec2(0.0015625, 0.0027778);\nmediump float params = 1.0;\nconst highp vec3 W = vec3(0.299,0.587,0.114);\nvec2 blurCoordinates[20];\nfloat hardLight(float color)\n{\n\tif(color <= 0.5)\n\t\tcolor = color * color * 2.0;\n\telse\n\t\tcolor = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n\treturn color;\n}\nfloat greenValue(vec2 coord)\n{\n   return texture2D(y_tex, coord).r - 0.344 * (texture2D(u_tex, coord).r - 0.5) - 0.714 * (texture2D(v_tex, coord).r - 0.5);\n}\nuniform float viewWidth;\nuniform float viewHeight;\nuniform float cornerRadius;\nbool isOutsideBottomLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideBottomRigthCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopRightCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideCorners() {\n       return isOutsideBottomLelftCorner() ||               isOutsideBottomRigthCorner() ||               isOutsideTopLelftCorner() ||               isOutsideTopRightCorner();\n}\nvoid main() {\n  vec3 centralColor = vec3(0., 0., 0.);\n  vec3 processedColor = vec3(0., 0., 0.);\n  if ((interp_tc.x > 1.) || (interp_tc.y > 1.) || (interp_tc.x < 0.) || (interp_tc.y < 0.)) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  } else if (isOutsideCorners()) \n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else {\n     float y = texture2D(y_tex, interp_tc).r;\n     float u = texture2D(u_tex, interp_tc).r - 0.5;\n     float v = texture2D(v_tex, interp_tc).r - 0.5;\n     centralColor = vec3(y + 1.403 * v,                           y - 0.344 * u - 0.714 * v,                           y + 1.77 * u);\n     float r = centralColor.r;\n     float g = centralColor.g;\n     float b = centralColor.b;\n     float Y  = 0.0 + 0.299 * r + 0.587 * g + 0.114 * b;\n     float Cb = 0.5 - 0.169 * r - 0.331 * g + 0.5   * b;\n     float Cr = 0.5 + 0.5   * r - 0.419 * g - 0.081 * b;\n     if ((Cb > 0.3008 && Cb < 0.5273 && Cr > 0.5078 && Cr < 0.6836) || Y > 0.7 ) \n     {\n        blurCoordinates[0] = interp_tc.xy + singleStepOffset * vec2(0.0, -10.0);\n        blurCoordinates[1] = interp_tc.xy + singleStepOffset * vec2(0.0, 10.0);\n        blurCoordinates[2] = interp_tc.xy + singleStepOffset * vec2(-10.0, 0.0);\n        blurCoordinates[3] = interp_tc.xy + singleStepOffset * vec2(10.0, 0.0);\n        blurCoordinates[4] = interp_tc.xy + singleStepOffset * vec2(5.0, -8.0);\n        blurCoordinates[5] = interp_tc.xy + singleStepOffset * vec2(5.0, 8.0);\n        blurCoordinates[6] = interp_tc.xy + singleStepOffset * vec2(-5.0, 8.0);\n        blurCoordinates[7] = interp_tc.xy + singleStepOffset * vec2(-5.0, -8.0);\n        blurCoordinates[8] = interp_tc.xy + singleStepOffset * vec2(8.0, -5.0);\n        blurCoordinates[9] = interp_tc.xy + singleStepOffset * vec2(8.0, 5.0);\n        blurCoordinates[10] = interp_tc.xy + singleStepOffset * vec2(-8.0, 5.0);\n        blurCoordinates[11] = interp_tc.xy + singleStepOffset * vec2(-8.0, -5.0);\n        blurCoordinates[12] = interp_tc.xy + singleStepOffset * vec2(0.0, -6.0);\n        blurCoordinates[13] = interp_tc.xy + singleStepOffset * vec2(0.0, 6.0);\n        blurCoordinates[14] = interp_tc.xy + singleStepOffset * vec2(6.0, 0.0);\n        blurCoordinates[15] = interp_tc.xy + singleStepOffset * vec2(-6.0, 0.0);\n        blurCoordinates[16] = interp_tc.xy + singleStepOffset * vec2(-4.0, -4.0);\n        blurCoordinates[17] = interp_tc.xy + singleStepOffset * vec2(-4.0, 4.0);\n        blurCoordinates[18] = interp_tc.xy + singleStepOffset * vec2(4.0, -4.0);\n        blurCoordinates[19] = interp_tc.xy + singleStepOffset * vec2(4.0, 4.0);\n        float sampleColor = centralColor.g * 20.0;\n        sampleColor += greenValue(blurCoordinates[0]);\n        sampleColor += greenValue(blurCoordinates[1]);\n        sampleColor += greenValue(blurCoordinates[2]);\n        sampleColor += greenValue(blurCoordinates[3]);\n        sampleColor += greenValue(blurCoordinates[4]);\n        sampleColor += greenValue(blurCoordinates[5]);\n        sampleColor += greenValue(blurCoordinates[6]);\n        sampleColor += greenValue(blurCoordinates[7]);\n        sampleColor += greenValue(blurCoordinates[8]);\n        sampleColor += greenValue(blurCoordinates[9]);\n        sampleColor += greenValue(blurCoordinates[10]);\n        sampleColor += greenValue(blurCoordinates[11]);\n        sampleColor += greenValue(blurCoordinates[12]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[13]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[14]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[15]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[16]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[17]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[18]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[19]) * 2.0;\n        sampleColor = sampleColor / 48.0;\n        float highPass = centralColor.g - sampleColor + 0.5;\n        for(int i = 0; i < 5; i++)\n        {\n            highPass = hardLight(highPass);\n        }\n        float luminance = dot(centralColor, W);\n        float alpha = pow(luminance, params);\n        vec3 smoothColor = centralColor + (centralColor-vec3(highPass))*alpha*0.1;\n        processedColor = vec3(mix(smoothColor.rgb, max(smoothColor, centralColor), alpha));\n     } else {\n        processedColor = centralColor;\n     }\n     float processedY  = 0.0 + 0.299 * processedColor.r + 0.587 * processedColor.g + 0.114 * processedColor.b;\n     if (processedY < 0.9) {\n       float value = exposureValue;\n       if (processedY * value > 0.9) {\n         value = 0.9 / processedY;\n       }\n       processedColor = processedColor * value;\n     }\n     gl_FragColor = vec4(processedColor.r, processedColor.g, processedColor.b, 1.);\n}}\n";
    private static final String BLUR_YUV_FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform sampler2D y_tex;\nuniform sampler2D u_tex;\nuniform sampler2D v_tex;\nuniform float exposureValue;\n\nvec2 singleStepOffset = vec2(0.0015625, 0.0027778);\nmediump float params = 1.0;\nconst highp vec3 W = vec3(0.299,0.587,0.114);\nvec2 blurCoordinates[20];\nfloat hardLight(float color)\n{\n\tif(color <= 0.5)\n\t\tcolor = color * color * 2.0;\n\telse\n\t\tcolor = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n\treturn color;\n}\nfloat greenValue(vec2 coord)\n{\n   return texture2D(y_tex, coord).r - 0.344 * (texture2D(u_tex, coord).r - 0.5) - 0.714 * (texture2D(v_tex, coord).r - 0.5);\n}\nvoid main() {\n  vec3 centralColor = vec3(0., 0., 0.);\n  vec3 processedColor = vec3(0., 0., 0.);\n  if ((interp_tc.x > 1.) || (interp_tc.y > 1.) || (interp_tc.x < 0.) || (interp_tc.y < 0.)) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  } else {\n     float y = texture2D(y_tex, interp_tc).r;\n     float u = texture2D(u_tex, interp_tc).r - 0.5;\n     float v = texture2D(v_tex, interp_tc).r - 0.5;\n     centralColor = vec3(y + 1.403 * v,                           y - 0.344 * u - 0.714 * v,                           y + 1.77 * u);\n     float r = centralColor.r;\n     float g = centralColor.g;\n     float b = centralColor.b;\n     float Y  = 0.0 + 0.299 * r + 0.587 * g + 0.114 * b;\n     float Cb = 0.5 - 0.169 * r - 0.331 * g + 0.5   * b;\n     float Cr = 0.5 + 0.5   * r - 0.419 * g - 0.081 * b;\n     if ((Cb > 0.3008 && Cb < 0.5273 && Cr > 0.5078 && Cr < 0.6836) || Y > 0.7 ) \n     {\n        blurCoordinates[0] = interp_tc.xy + singleStepOffset * vec2(0.0, -10.0);\n        blurCoordinates[1] = interp_tc.xy + singleStepOffset * vec2(0.0, 10.0);\n        blurCoordinates[2] = interp_tc.xy + singleStepOffset * vec2(-10.0, 0.0);\n        blurCoordinates[3] = interp_tc.xy + singleStepOffset * vec2(10.0, 0.0);\n        blurCoordinates[4] = interp_tc.xy + singleStepOffset * vec2(5.0, -8.0);\n        blurCoordinates[5] = interp_tc.xy + singleStepOffset * vec2(5.0, 8.0);\n        blurCoordinates[6] = interp_tc.xy + singleStepOffset * vec2(-5.0, 8.0);\n        blurCoordinates[7] = interp_tc.xy + singleStepOffset * vec2(-5.0, -8.0);\n        blurCoordinates[8] = interp_tc.xy + singleStepOffset * vec2(8.0, -5.0);\n        blurCoordinates[9] = interp_tc.xy + singleStepOffset * vec2(8.0, 5.0);\n        blurCoordinates[10] = interp_tc.xy + singleStepOffset * vec2(-8.0, 5.0);\n        blurCoordinates[11] = interp_tc.xy + singleStepOffset * vec2(-8.0, -5.0);\n        blurCoordinates[12] = interp_tc.xy + singleStepOffset * vec2(0.0, -6.0);\n        blurCoordinates[13] = interp_tc.xy + singleStepOffset * vec2(0.0, 6.0);\n        blurCoordinates[14] = interp_tc.xy + singleStepOffset * vec2(6.0, 0.0);\n        blurCoordinates[15] = interp_tc.xy + singleStepOffset * vec2(-6.0, 0.0);\n        blurCoordinates[16] = interp_tc.xy + singleStepOffset * vec2(-4.0, -4.0);\n        blurCoordinates[17] = interp_tc.xy + singleStepOffset * vec2(-4.0, 4.0);\n        blurCoordinates[18] = interp_tc.xy + singleStepOffset * vec2(4.0, -4.0);\n        blurCoordinates[19] = interp_tc.xy + singleStepOffset * vec2(4.0, 4.0);\n        float sampleColor = centralColor.g * 20.0;\n        sampleColor += greenValue(blurCoordinates[0]);\n        sampleColor += greenValue(blurCoordinates[1]);\n        sampleColor += greenValue(blurCoordinates[2]);\n        sampleColor += greenValue(blurCoordinates[3]);\n        sampleColor += greenValue(blurCoordinates[4]);\n        sampleColor += greenValue(blurCoordinates[5]);\n        sampleColor += greenValue(blurCoordinates[6]);\n        sampleColor += greenValue(blurCoordinates[7]);\n        sampleColor += greenValue(blurCoordinates[8]);\n        sampleColor += greenValue(blurCoordinates[9]);\n        sampleColor += greenValue(blurCoordinates[10]);\n        sampleColor += greenValue(blurCoordinates[11]);\n        sampleColor += greenValue(blurCoordinates[12]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[13]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[14]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[15]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[16]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[17]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[18]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[19]) * 2.0;\n        sampleColor = sampleColor / 48.0;\n        float highPass = centralColor.g - sampleColor + 0.5;\n        for(int i = 0; i < 5; i++)\n        {\n            highPass = hardLight(highPass);\n        }\n        float luminance = dot(centralColor, W);\n        float alpha = pow(luminance, params);\n        vec3 smoothColor = centralColor + (centralColor-vec3(highPass))*alpha*0.1;\n        processedColor = vec3(mix(smoothColor.rgb, max(smoothColor, centralColor), alpha));\n     } else {\n        processedColor = centralColor;\n     }\n     float processedY  = 0.0 + 0.299 * processedColor.r + 0.587 * processedColor.g + 0.114 * processedColor.b;\n     if (processedY < 0.9) {\n       float value = exposureValue;\n       if (processedY * value > 0.9) {\n         value = 0.9 / processedY;\n       }\n       processedColor = processedColor * value;\n     }\n     gl_FragColor = vec4(processedColor.r, processedColor.g, processedColor.b, 1.);\n  }\n}\n";
    private static final String DEFINE_CORNER_RENDER = "uniform float viewWidth;\nuniform float viewHeight;\nuniform float cornerRadius;\nbool isOutsideBottomLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideBottomRigthCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopRightCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideCorners() {\n       return isOutsideBottomLelftCorner() ||               isOutsideBottomRigthCorner() ||               isOutsideTopLelftCorner() ||               isOutsideTopRightCorner();\n}\n";
    private static final String DEFINE_OES_BLUR_RENDER = "precision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform samplerExternalOES oes_tex;\nuniform float exposureValue;\nvec2 singleStepOffset = vec2(0.0015625, 0.0027778);\nmediump float params = 1.0;\nconst highp vec3 W = vec3(0.299,0.587,0.114);\nvec2 blurCoordinates[20];\nfloat hardLight(float color)\n{\n\tif(color <= 0.5)\n\t\tcolor = color * color * 2.0;\n\telse\n\t\tcolor = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n\treturn color;\n}\n";
    private static final String DEFINE_OES_RENDER = "precision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform samplerExternalOES oes_tex;\n";
    private static final String DEFINE_SKIN_DETECT_RGB = "     if (r > 0.3725 && g > 0.1568 && b > 0.0784 && r > b && (max(max(r, g), b) - min(min(r, g), b)) > 0.0588 && abs(r-g) > 0.0588) \n";
    private static final String DEFINE_SKIN_DETECT_YCRCB = "     float Y  = 0.0 + 0.299 * r + 0.587 * g + 0.114 * b;\n     float Cb = 0.5 - 0.169 * r - 0.331 * g + 0.5   * b;\n     float Cr = 0.5 + 0.5   * r - 0.419 * g - 0.081 * b;\n     if ((Cb > 0.3008 && Cb < 0.5273 && Cr > 0.5078 && Cr < 0.6836) || Y > 0.7 ) \n";
    private static final String DEFINE_YUV_BLUR_RENDER = "precision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform sampler2D y_tex;\nuniform sampler2D u_tex;\nuniform sampler2D v_tex;\nuniform float exposureValue;\n\nvec2 singleStepOffset = vec2(0.0015625, 0.0027778);\nmediump float params = 1.0;\nconst highp vec3 W = vec3(0.299,0.587,0.114);\nvec2 blurCoordinates[20];\nfloat hardLight(float color)\n{\n\tif(color <= 0.5)\n\t\tcolor = color * color * 2.0;\n\telse\n\t\tcolor = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n\treturn color;\n}\nfloat greenValue(vec2 coord)\n{\n   return texture2D(y_tex, coord).r - 0.344 * (texture2D(u_tex, coord).r - 0.5) - 0.714 * (texture2D(v_tex, coord).r - 0.5);\n}\n";
    private static final String DEFINE_YUV_RENDER = "varying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform sampler2D y_tex;\nuniform sampler2D u_tex;\nuniform sampler2D v_tex;\n";
    private static final String FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nvarying vec2 interp_tc;\n\nuniform sampler2D oes_tex;\n\nvoid main() {\n  gl_FragColor = texture2D(oes_tex, interp_tc);\n}\n";
    private static final FloatBuffer FULL_RECTANGLE_BUF = GlUtil.createFloatBuffer(new float[]{-1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f});
    private static final FloatBuffer FULL_RECTANGLE_TEX_BUF = GlUtil.createFloatBuffer(new float[]{0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f});
    private static final String HIGHPASS_HARDLIGHT = "float hardLight(float color)\n{\n\tif(color <= 0.5)\n\t\tcolor = color * color * 2.0;\n\telse\n\t\tcolor = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n\treturn color;\n}\n";
    private static final String IMPLEMENT_OES_BLUR_RENDER = "    vec3 centralColor = texture2D(oes_tex, interp_tc).rgb;\n    vec3 processedColor = centralColor;\n    float r = centralColor.r;\n    float g = centralColor.g;\n    float b = centralColor.b;\n     float Y  = 0.0 + 0.299 * r + 0.587 * g + 0.114 * b;\n     float Cb = 0.5 - 0.169 * r - 0.331 * g + 0.5   * b;\n     float Cr = 0.5 + 0.5   * r - 0.419 * g - 0.081 * b;\n     if ((Cb > 0.3008 && Cb < 0.5273 && Cr > 0.5078 && Cr < 0.6836) || Y > 0.7 ) \n    {\n        blurCoordinates[0] = interp_tc.xy + singleStepOffset * vec2(0.0, -10.0);\n        blurCoordinates[1] = interp_tc.xy + singleStepOffset * vec2(0.0, 10.0);\n        blurCoordinates[2] = interp_tc.xy + singleStepOffset * vec2(-10.0, 0.0);\n        blurCoordinates[3] = interp_tc.xy + singleStepOffset * vec2(10.0, 0.0);\n        blurCoordinates[4] = interp_tc.xy + singleStepOffset * vec2(5.0, -8.0);\n        blurCoordinates[5] = interp_tc.xy + singleStepOffset * vec2(5.0, 8.0);\n        blurCoordinates[6] = interp_tc.xy + singleStepOffset * vec2(-5.0, 8.0);\n        blurCoordinates[7] = interp_tc.xy + singleStepOffset * vec2(-5.0, -8.0);\n        blurCoordinates[8] = interp_tc.xy + singleStepOffset * vec2(8.0, -5.0);\n        blurCoordinates[9] = interp_tc.xy + singleStepOffset * vec2(8.0, 5.0);\n        blurCoordinates[10] = interp_tc.xy + singleStepOffset * vec2(-8.0, 5.0);\n        blurCoordinates[11] = interp_tc.xy + singleStepOffset * vec2(-8.0, -5.0);\n        blurCoordinates[12] = interp_tc.xy + singleStepOffset * vec2(0.0, -6.0);\n        blurCoordinates[13] = interp_tc.xy + singleStepOffset * vec2(0.0, 6.0);\n        blurCoordinates[14] = interp_tc.xy + singleStepOffset * vec2(6.0, 0.0);\n        blurCoordinates[15] = interp_tc.xy + singleStepOffset * vec2(-6.0, 0.0);\n        blurCoordinates[16] = interp_tc.xy + singleStepOffset * vec2(-4.0, -4.0);\n        blurCoordinates[17] = interp_tc.xy + singleStepOffset * vec2(-4.0, 4.0);\n        blurCoordinates[18] = interp_tc.xy + singleStepOffset * vec2(4.0, -4.0);\n        blurCoordinates[19] = interp_tc.xy + singleStepOffset * vec2(4.0, 4.0);\n        float sampleColor = centralColor.g * 20.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[0]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[1]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[2]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[3]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[4]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[5]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[6]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[7]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[8]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[9]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[10]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[11]).g;\n        sampleColor += texture2D(oes_tex, blurCoordinates[12]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[13]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[14]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[15]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[16]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[17]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[18]).g * 2.0;\n        sampleColor += texture2D(oes_tex, blurCoordinates[19]).g * 2.0;\n        sampleColor = sampleColor / 48.0;\n        float highPass = centralColor.g - sampleColor + 0.5;\n        for(int i = 0; i < 5; i++)\n        {\n            highPass = hardLight(highPass);\n        }\n        float luminance = dot(centralColor, W);\n        float alpha = pow(luminance, params);\n        vec3 smoothColor = centralColor + (centralColor-vec3(highPass))*alpha*0.1;\n        processedColor = vec3(mix(smoothColor.rgb, max(smoothColor, centralColor), alpha));\n    } else {\n        processedColor = centralColor;    }\n    float processedY  = 0.0 + 0.299 * processedColor.r + 0.587 * processedColor.g + 0.114 * processedColor.b;\n    if (processedY < 0.9) {\n       float value = exposureValue;\n       if (processedY * value > 0.9) {\n         value = 0.9 / processedY;\n       }\n       processedColor = processedColor * value;\n    }\n    gl_FragColor = vec4(processedColor.r, processedColor.g, processedColor.b, 1.);\n";
    private static final String IMPLEMENT_YUV_BLUR_RENDER = "     float y = texture2D(y_tex, interp_tc).r;\n     float u = texture2D(u_tex, interp_tc).r - 0.5;\n     float v = texture2D(v_tex, interp_tc).r - 0.5;\n     centralColor = vec3(y + 1.403 * v,                           y - 0.344 * u - 0.714 * v,                           y + 1.77 * u);\n     float r = centralColor.r;\n     float g = centralColor.g;\n     float b = centralColor.b;\n     float Y  = 0.0 + 0.299 * r + 0.587 * g + 0.114 * b;\n     float Cb = 0.5 - 0.169 * r - 0.331 * g + 0.5   * b;\n     float Cr = 0.5 + 0.5   * r - 0.419 * g - 0.081 * b;\n     if ((Cb > 0.3008 && Cb < 0.5273 && Cr > 0.5078 && Cr < 0.6836) || Y > 0.7 ) \n     {\n        blurCoordinates[0] = interp_tc.xy + singleStepOffset * vec2(0.0, -10.0);\n        blurCoordinates[1] = interp_tc.xy + singleStepOffset * vec2(0.0, 10.0);\n        blurCoordinates[2] = interp_tc.xy + singleStepOffset * vec2(-10.0, 0.0);\n        blurCoordinates[3] = interp_tc.xy + singleStepOffset * vec2(10.0, 0.0);\n        blurCoordinates[4] = interp_tc.xy + singleStepOffset * vec2(5.0, -8.0);\n        blurCoordinates[5] = interp_tc.xy + singleStepOffset * vec2(5.0, 8.0);\n        blurCoordinates[6] = interp_tc.xy + singleStepOffset * vec2(-5.0, 8.0);\n        blurCoordinates[7] = interp_tc.xy + singleStepOffset * vec2(-5.0, -8.0);\n        blurCoordinates[8] = interp_tc.xy + singleStepOffset * vec2(8.0, -5.0);\n        blurCoordinates[9] = interp_tc.xy + singleStepOffset * vec2(8.0, 5.0);\n        blurCoordinates[10] = interp_tc.xy + singleStepOffset * vec2(-8.0, 5.0);\n        blurCoordinates[11] = interp_tc.xy + singleStepOffset * vec2(-8.0, -5.0);\n        blurCoordinates[12] = interp_tc.xy + singleStepOffset * vec2(0.0, -6.0);\n        blurCoordinates[13] = interp_tc.xy + singleStepOffset * vec2(0.0, 6.0);\n        blurCoordinates[14] = interp_tc.xy + singleStepOffset * vec2(6.0, 0.0);\n        blurCoordinates[15] = interp_tc.xy + singleStepOffset * vec2(-6.0, 0.0);\n        blurCoordinates[16] = interp_tc.xy + singleStepOffset * vec2(-4.0, -4.0);\n        blurCoordinates[17] = interp_tc.xy + singleStepOffset * vec2(-4.0, 4.0);\n        blurCoordinates[18] = interp_tc.xy + singleStepOffset * vec2(4.0, -4.0);\n        blurCoordinates[19] = interp_tc.xy + singleStepOffset * vec2(4.0, 4.0);\n        float sampleColor = centralColor.g * 20.0;\n        sampleColor += greenValue(blurCoordinates[0]);\n        sampleColor += greenValue(blurCoordinates[1]);\n        sampleColor += greenValue(blurCoordinates[2]);\n        sampleColor += greenValue(blurCoordinates[3]);\n        sampleColor += greenValue(blurCoordinates[4]);\n        sampleColor += greenValue(blurCoordinates[5]);\n        sampleColor += greenValue(blurCoordinates[6]);\n        sampleColor += greenValue(blurCoordinates[7]);\n        sampleColor += greenValue(blurCoordinates[8]);\n        sampleColor += greenValue(blurCoordinates[9]);\n        sampleColor += greenValue(blurCoordinates[10]);\n        sampleColor += greenValue(blurCoordinates[11]);\n        sampleColor += greenValue(blurCoordinates[12]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[13]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[14]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[15]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[16]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[17]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[18]) * 2.0;\n        sampleColor += greenValue(blurCoordinates[19]) * 2.0;\n        sampleColor = sampleColor / 48.0;\n        float highPass = centralColor.g - sampleColor + 0.5;\n        for(int i = 0; i < 5; i++)\n        {\n            highPass = hardLight(highPass);\n        }\n        float luminance = dot(centralColor, W);\n        float alpha = pow(luminance, params);\n        vec3 smoothColor = centralColor + (centralColor-vec3(highPass))*alpha*0.1;\n        processedColor = vec3(mix(smoothColor.rgb, max(smoothColor, centralColor), alpha));\n     } else {\n        processedColor = centralColor;\n     }\n     float processedY  = 0.0 + 0.299 * processedColor.r + 0.587 * processedColor.g + 0.114 * processedColor.b;\n     if (processedY < 0.9) {\n       float value = exposureValue;\n       if (processedY * value > 0.9) {\n         value = 0.9 / processedY;\n       }\n       processedColor = processedColor * value;\n     }\n     gl_FragColor = vec4(processedColor.r, processedColor.g, processedColor.b, 1.);\n";
    private static final String IMPLEMENT_YUV_RENDER = "     float y = texture2D(y_tex, interp_tc).r;\n     float u = texture2D(u_tex, interp_tc).r - 0.5;\n     float v = texture2D(v_tex, interp_tc).r - 0.5;\n     gl_FragColor = vec4(y + 1.403 * v,                           y - 0.344 * u - 0.714 * v,                           y + 1.77 * u, 1.);\n";
    private static final String OES_CIRCLE_FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform samplerExternalOES oes_tex;\nvoid main() {\n  float r2 = (real_coord.x - 0.5) * (real_coord.x - 0.5) + (real_coord.y - 0.5)*(real_coord.y - 0.5);\n  if (r2 > 0.25) \n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else \n      gl_FragColor = texture2D(oes_tex, interp_tc);\n}\n";
    private static final String OES_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform samplerExternalOES oes_tex;\nuniform float viewWidth;\nuniform float viewHeight;\nuniform float cornerRadius;\nbool isOutsideBottomLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideBottomRigthCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopRightCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideCorners() {\n       return isOutsideBottomLelftCorner() ||               isOutsideBottomRigthCorner() ||               isOutsideTopLelftCorner() ||               isOutsideTopRightCorner();\n}\nvoid main() {\n  if (isOutsideCorners()) \n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else \n      gl_FragColor = texture2D(oes_tex, interp_tc);\n}\n";
    private static final String OES_FRAGMENT_SHADER_STRING = "#extension GL_OES_EGL_image_external : require\nprecision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform samplerExternalOES oes_tex;\nvoid main() {\n  gl_FragColor = texture2D(oes_tex, interp_tc);\n}\n";
    private static final String RGB_CIRCLE_FRAGMENT_SHADER_STRING = "precision mediump float;\nvarying vec2 interp_tc;\nuniform sampler2D rgb_tex;\n\nvoid main() {\n  float r2 = (real_coord.x - 0.5) * (real_coord.x - 0.5) + (real_coord.y - 0.5)*(real_coord.y - 0.5);\n  if (r2 > 0.25) \n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else \n      gl_FragColor = texture2D(rgb_tex, interp_tc);\n}\n";
    private static final String RGB_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING = "precision mediump float;\nvarying vec2 interp_tc;\n\nuniform sampler2D rgb_tex;\n\nuniform float viewWidth;\nuniform float viewHeight;\nuniform float cornerRadius;\nbool isOutsideBottomLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideBottomRigthCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopRightCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideCorners() {\n       return isOutsideBottomLelftCorner() ||               isOutsideBottomRigthCorner() ||               isOutsideTopLelftCorner() ||               isOutsideTopRightCorner();\n}\nvoid main() {\n  if (isOutsideCorners()) \n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else \n      gl_FragColor = texture2D(rgb_tex, interp_tc);\n}\n";
    private static final String RGB_FRAGMENT_SHADER_STRING = "precision mediump float;\nvarying vec2 interp_tc;\n\nuniform sampler2D rgb_tex;\n\nvoid main() {\n  gl_FragColor = texture2D(rgb_tex, interp_tc);\n}\n";
    private static final String VERTEX_SHADER_STRING = "varying vec2 interp_tc;\nvarying vec2 real_coord;\nattribute vec4 in_pos;\nattribute vec4 in_tc;\n\nuniform mat4 texMatrix;\n\nvoid main() {\n    gl_Position = in_pos;\n    interp_tc = (texMatrix * in_tc).xy;\n    real_coord = (in_tc).xy;\n}\n";
    private static final String YUV_CIRCLE_FRAGMENT_SHADER_STRING = "precision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform sampler2D y_tex;\nuniform sampler2D u_tex;\nuniform sampler2D v_tex;\n\nvoid main() {\n  float r2 = (real_coord.x - 0.5) * (real_coord.x - 0.5) + (real_coord.y - 0.5)*(real_coord.y - 0.5);\n  if (r2 > 0.25) \n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  else { \n     float y = texture2D(y_tex, interp_tc).r;\n     float u = texture2D(u_tex, interp_tc).r - 0.5;\n     float v = texture2D(v_tex, interp_tc).r - 0.5;\n     gl_FragColor = vec4(y + 1.403 * v,                           y - 0.344 * u - 0.714 * v,                           y + 1.77 * u, 1.);\n  }\n}\n";
    private static final String YUV_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING = "precision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform sampler2D y_tex;\nuniform sampler2D u_tex;\nuniform sampler2D v_tex;\nuniform float viewWidth;\nuniform float viewHeight;\nuniform float cornerRadius;\nbool isOutsideBottomLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideBottomRigthCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y < cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopLelftCorner() {\n   return gl_FragCoord.x < cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideTopRightCorner() {\n   return gl_FragCoord.x > viewWidth - cornerRadius && gl_FragCoord.y > viewHeight - cornerRadius && distance(gl_FragCoord.xy, vec2(viewWidth - cornerRadius, viewHeight - cornerRadius)) > cornerRadius;\n}\nbool isOutsideCorners() {\n       return isOutsideBottomLelftCorner() ||               isOutsideBottomRigthCorner() ||               isOutsideTopLelftCorner() ||               isOutsideTopRightCorner();\n}\nvoid main() {\n  if ((interp_tc.x > 1.) || (interp_tc.y > 1.) || (interp_tc.x < 0.) || (interp_tc.y < 0.)) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  } else if (isOutsideCorners()) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n  } else {\n     float y = texture2D(y_tex, interp_tc).r;\n     float u = texture2D(u_tex, interp_tc).r - 0.5;\n     float v = texture2D(v_tex, interp_tc).r - 0.5;\n     gl_FragColor = vec4(y + 1.403 * v,                           y - 0.344 * u - 0.714 * v,                           y + 1.77 * u, 1.);\n  }}\n";
    private static final String YUV_FRAGMENT_SHADER_STRING = "precision mediump float;\nvarying vec2 interp_tc;\nvarying vec2 real_coord;\nuniform sampler2D y_tex;\nuniform sampler2D u_tex;\nuniform sampler2D v_tex;\n\nvoid main() {\n  vec4 color = vec4(0., 0., 0., 1.0);\n  if ((interp_tc.x > 1.) || (interp_tc.y > 1.) || (interp_tc.x < 0.) || (interp_tc.y < 0.)) {\n      gl_FragColor = color;\n  } else {\n     float y = texture2D(y_tex, interp_tc).r;\n     float u = texture2D(u_tex, interp_tc).r - 0.5;\n     float v = texture2D(v_tex, interp_tc).r - 0.5;\n     gl_FragColor = vec4(y + 1.403 * v,                           y - 0.344 * u - 0.714 * v,                           y + 1.77 * u, 1.);\n  }}\n";
    private final Map<String, Shader> shaders = new IdentityHashMap();

    /* JADX INFO: Access modifiers changed from: private */
    /* loaded from: classes7.dex */
    public static class Shader {
        public final GlShader glShader;
        public final int texMatrixLocation;

        public Shader(String str, boolean z11) {
            GlShader glShader = new GlShader(GlRectDrawer.VERTEX_SHADER_STRING, str);
            this.glShader = glShader;
            if (z11) {
                this.texMatrixLocation = -1;
            } else {
                this.texMatrixLocation = glShader.getUniformLocation("texMatrix");
            }
        }
    }

    private void drawRectangle(int i11, int i12, int i13, int i14) {
        GLES20.glViewport(i11, i12, i13, i14);
        GLES20.glDrawArrays(5, 0, 4);
    }

    private void prepareShader(String str, float[] fArr, int i11, int i12, float f11, float f12) {
        Shader shader;
        boolean equals = str.equals(BLACK_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING);
        if (this.shaders.containsKey(str)) {
            shader = this.shaders.get(str);
        } else {
            Shader shader2 = new Shader(str, equals);
            this.shaders.put(str, shader2);
            shader2.glShader.useProgram();
            if (!str.equals(YUV_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING) && !str.equals(BLUR_YUV_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING)) {
                if (str.equals(OES_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING) || str.equals(BLACK_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING) || str.equals(BLUR_OES_CIRCLE_FRAGMENT_SHADER_STRING)) {
                    GLES20.glUniform1i(shader2.glShader.getUniformLocation("oes_tex"), 0);
                }
            } else {
                GLES20.glUniform1i(shader2.glShader.getUniformLocation("y_tex"), 0);
                GLES20.glUniform1i(shader2.glShader.getUniformLocation("u_tex"), 1);
                GLES20.glUniform1i(shader2.glShader.getUniformLocation("v_tex"), 2);
            }
            if (str.equals(BLUR_OES_CIRCLE_FRAGMENT_SHADER_STRING) || str.equals(BLUR_OES_FRAGMENT_SHADER_STRING) || str.equals(BLUR_OES_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING) || str.equals(BLUR_YUV_CIRCLE_FRAGMENT_SHADER_STRING) || str.equals(BLUR_YUV_FRAGMENT_SHADER_STRING) || str.equals(BLUR_YUV_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING)) {
                GLES20.glUniform1f(shader2.glShader.getUniformLocation("exposureValue"), f12);
            }
            GlUtil.checkNoGLES2Error("Initialize fragment shader uniform values.");
            shader = shader2;
        }
        shader.glShader.useProgram();
        GLES20.glUniform1f(shader.glShader.getUniformLocation("viewWidth"), i11);
        GLES20.glUniform1f(shader.glShader.getUniformLocation("viewHeight"), i12);
        GLES20.glUniform1f(shader.glShader.getUniformLocation("cornerRadius"), f11);
        shader.glShader.setVertexAttribArray("in_pos", 2, FULL_RECTANGLE_BUF);
        if (!equals) {
            try {
                shader.glShader.setVertexAttribArray("in_tc", 2, FULL_RECTANGLE_TEX_BUF);
            } catch (Exception e11) {
                e11.printStackTrace();
                return;
            }
        }
        GLES20.glUniformMatrix4fv(shader.texMatrixLocation, 1, false, fArr, 0);
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawBlack(float[] fArr, int i11, int i12, int i13, int i14) {
        prepareShader(BLACK_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        drawRectangle(i11, i12, i13, i14);
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawBlackCircle(float[] fArr, int i11, int i12, int i13, int i14) {
        prepareShader(BLACK_CIRCLE_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        drawRectangle(i11, i12, i13, i14);
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawBlackCornerRectangle(float[] fArr, int i11, int i12, int i13, int i14, float f11) {
        prepareShader(BLACK_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING, fArr, i13, i14, f11, 1.0f);
        drawRectangle(i11, i12, i13, i14);
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawOes(int i11, float[] fArr, int i12, int i13, int i14, int i15, int i16, int i17, boolean z11) {
        if (z11) {
            prepareShader(BLACK_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        } else if (ZVideoFilterManager.filterType() == ZVideoFilter.FilterType.NATIVE.getValue()) {
            prepareShader(BLUR_OES_FRAGMENT_SHADER_STRING, fArr, ZVideoFilterManager.getExposureValue());
        } else {
            prepareShader(OES_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        }
        GLES20.glActiveTexture(33984);
        GLES20.glBindTexture(36197, i11);
        drawRectangle(i14, i15, i16, i17);
        GLES20.glBindTexture(36197, 0);
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawOesCircle(int i11, float[] fArr, int i12, int i13, int i14, int i15, int i16, int i17, boolean z11) {
        if (z11) {
            prepareShader(BLACK_CIRCLE_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        } else if (ZVideoFilterManager.filterType() == ZVideoFilter.FilterType.NATIVE.getValue()) {
            prepareShader(BLUR_OES_CIRCLE_FRAGMENT_SHADER_STRING, fArr, ZVideoFilterManager.getExposureValue());
        } else {
            prepareShader(OES_CIRCLE_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        }
        GLES20.glActiveTexture(33984);
        GLES20.glBindTexture(36197, i11);
        drawRectangle(i14, i15, i16, i17);
        GLES20.glBindTexture(36197, 0);
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawOesCornerRectangle(int i11, float[] fArr, int i12, int i13, int i14, int i15, int i16, int i17, float f11) {
        if (ZVideoFilterManager.filterType() == ZVideoFilter.FilterType.NATIVE.getValue()) {
            prepareShader(BLUR_OES_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING, fArr, i16, i17, f11, ZVideoFilterManager.getExposureValue());
        } else {
            prepareShader(OES_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING, fArr, i16, i17, f11, f11);
        }
        GLES20.glActiveTexture(33984);
        GLES20.glBindTexture(36197, i11);
        drawRectangle(i14, i15, i16, i17);
        GLES20.glBindTexture(36197, 0);
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawRGB(int i11, float[] fArr, int i12, int i13, int i14, int i15, int i16, int i17, boolean z11) {
        if (z11) {
            prepareShader(BLACK_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        } else {
            prepareShader(RGB_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        }
        GLES20.glActiveTexture(33984);
        GLES20.glBindTexture(3553, i11);
        drawRectangle(i14, i15, i16, i17);
        GLES20.glBindTexture(3553, 0);
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawRGBCircle(int i11, float[] fArr, int i12, int i13, int i14, int i15, int i16, int i17, boolean z11) {
        if (z11) {
            prepareShader(BLACK_CIRCLE_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        } else {
            prepareShader(RGB_CIRCLE_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        }
        GLES20.glActiveTexture(33984);
        GLES20.glBindTexture(3553, i11);
        drawRectangle(i14, i15, i16, i17);
        GLES20.glBindTexture(3553, 0);
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawRGBCornerRectangle(int i11, float[] fArr, int i12, int i13, int i14, int i15, int i16, int i17, float f11) {
        prepareShader(RGB_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING, fArr, i16, i17, f11, 1.0f);
        GLES20.glActiveTexture(33984);
        GLES20.glBindTexture(3553, i11);
        drawRectangle(i14, i15, i16, i17);
        GLES20.glBindTexture(3553, 0);
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawYuv(int[] iArr, float[] fArr, int i11, int i12, int i13, int i14, int i15, int i16, boolean z11) {
        if (z11) {
            prepareShader(BLUR_YUV_FRAGMENT_SHADER_STRING, fArr, ZVideoFilterManager.getExposureValue());
        } else {
            prepareShader(YUV_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        }
        for (int i17 = 0; i17 < 3; i17++) {
            GLES20.glActiveTexture(33984 + i17);
            GLES20.glBindTexture(3553, iArr[i17]);
        }
        drawRectangle(i13, i14, i15, i16);
        for (int i18 = 0; i18 < 3; i18++) {
            GLES20.glActiveTexture(i18 + 33984);
            GLES20.glBindTexture(3553, 0);
        }
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawYuvCircle(int[] iArr, float[] fArr, int i11, int i12, int i13, int i14, int i15, int i16, boolean z11) {
        if (z11) {
            prepareShader(BLUR_YUV_CIRCLE_FRAGMENT_SHADER_STRING, fArr, ZVideoFilterManager.getExposureValue());
        } else {
            prepareShader(YUV_CIRCLE_FRAGMENT_SHADER_STRING, fArr, 1.0f);
        }
        for (int i17 = 0; i17 < 3; i17++) {
            GLES20.glActiveTexture(33984 + i17);
            GLES20.glBindTexture(3553, iArr[i17]);
        }
        drawRectangle(i13, i14, i15, i16);
        for (int i18 = 0; i18 < 3; i18++) {
            GLES20.glActiveTexture(i18 + 33984);
            GLES20.glBindTexture(3553, 0);
        }
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void drawYuvCornerRectangle(int[] iArr, float[] fArr, int i11, int i12, int i13, int i14, int i15, int i16, float f11, boolean z11) {
        if (z11) {
            prepareShader(BLUR_YUV_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING, fArr, i15, i16, f11, ZVideoFilterManager.getExposureValue());
        } else {
            prepareShader(YUV_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING, fArr, i15, i16, f11, 1.0f);
        }
        for (int i17 = 0; i17 < 3; i17++) {
            GLES20.glActiveTexture(33984 + i17);
            GLES20.glBindTexture(3553, iArr[i17]);
        }
        drawRectangle(i13, i14, i15, i16);
        for (int i18 = 0; i18 < 3; i18++) {
            GLES20.glActiveTexture(i18 + 33984);
            GLES20.glBindTexture(3553, 0);
        }
    }

    @Override // org.webrtc.RendererCommon.GlDrawer
    public void release() {
        Iterator<Shader> it = this.shaders.values().iterator();
        while (it.hasNext()) {
            it.next().glShader.release();
        }
        this.shaders.clear();
    }

    private void prepareShader(String str, float[] fArr, float f11) {
        Shader shader;
        boolean z11 = str.equals(BLACK_FRAGMENT_SHADER_STRING) || str.equals(BLACK_CIRCLE_FRAGMENT_SHADER_STRING);
        if (this.shaders.containsKey(str)) {
            shader = this.shaders.get(str);
        } else {
            Shader shader2 = new Shader(str, z11);
            this.shaders.put(str, shader2);
            shader2.glShader.useProgram();
            if (!str.equals(YUV_FRAGMENT_SHADER_STRING) && !str.equals(BLUR_YUV_FRAGMENT_SHADER_STRING) && !str.equals(YUV_CIRCLE_FRAGMENT_SHADER_STRING) && !str.equals(BLUR_YUV_CIRCLE_FRAGMENT_SHADER_STRING)) {
                if (str.equals(RGB_FRAGMENT_SHADER_STRING)) {
                    GLES20.glUniform1i(shader2.glShader.getUniformLocation("rgb_tex"), 0);
                } else if (!str.equals(OES_FRAGMENT_SHADER_STRING) && !str.equals(OES_CIRCLE_FRAGMENT_SHADER_STRING) && !str.equals(BLUR_OES_FRAGMENT_SHADER_STRING) && !str.equals(BLUR_OES_CIRCLE_FRAGMENT_SHADER_STRING)) {
                    if (!str.equals(BLACK_FRAGMENT_SHADER_STRING) && !str.equals(BLACK_CIRCLE_FRAGMENT_SHADER_STRING)) {
                        throw new IllegalStateException("Unknown fragment shader: " + str);
                    }
                } else {
                    GLES20.glUniform1i(shader2.glShader.getUniformLocation("oes_tex"), 0);
                }
            } else {
                GLES20.glUniform1i(shader2.glShader.getUniformLocation("y_tex"), 0);
                GLES20.glUniform1i(shader2.glShader.getUniformLocation("u_tex"), 1);
                GLES20.glUniform1i(shader2.glShader.getUniformLocation("v_tex"), 2);
            }
            if (str.equals(BLUR_OES_FRAGMENT_SHADER_STRING) || str.equals(BLUR_OES_CIRCLE_FRAGMENT_SHADER_STRING) || str.equals(BLUR_OES_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING) || str.equals(BLUR_YUV_CIRCLE_FRAGMENT_SHADER_STRING) || str.equals(BLUR_YUV_FRAGMENT_SHADER_STRING) || str.equals(BLUR_YUV_CORNER_RECTANGLE_FRAGMENT_SHADER_STRING)) {
                GLES20.glUniform1f(shader2.glShader.getUniformLocation("exposureValue"), f11);
            }
            GlUtil.checkNoGLES2Error("Initialize fragment shader uniform values.");
            shader = shader2;
        }
        shader.glShader.useProgram();
        shader.glShader.setVertexAttribArray("in_pos", 2, FULL_RECTANGLE_BUF);
        if (z11) {
            try {
                shader.glShader.setVertexAttribArray("in_tc", 2, FULL_RECTANGLE_TEX_BUF);
                GLES20.glUniformMatrix4fv(shader.texMatrixLocation, 1, false, fArr, 0);
                return;
            } catch (Exception e11) {
                AbstractC20110a.m104546o(e11);
                return;
            }
        }
        shader.glShader.setVertexAttribArray("in_tc", 2, FULL_RECTANGLE_TEX_BUF);
        GLES20.glUniformMatrix4fv(shader.texMatrixLocation, 1, false, fArr, 0);
    }
}
